---
title: Analyse de l'impact des aires protégées à Madagascar à partir de la méthode
  KfW
output:
  pdf_document: default
  html_document: default
date: '2022-07-12'
editor_options:
  chunk_output_type: console
---

On réutilise le code fourni par Johannes Schielein: Jochen Kluve, Johannes Schielein, Melvin Wong, Yota Eilers, The KfW Protected Areas Portfolio: a Rigorous Impact Evaluation, KfW, 2022-07-08.

```{r Librairies et paramètres, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(sf)
library(wdpar)
library(tmap)
library(mapview) # à enlever ? redondant avec tmap
library(geodata)
library(tidygeocoder)
library(maptiles)
# Système de coordonnées géographiques utilisées pour le projet
mon_scr <- "EPSG:29739"
# taille du rayon des hexagones
taille_hex <- 5
# Taille des titres des cartes
map_title_size = 0.7
```



# On charge les données de WDPA

```{r Chargement des données, echo=FALSE, message=FALSE, warning=FALSE}

# Téléchargement et chargement dans R des données d'aires protégées malgaches
aires_prot_mada <- wdpa_fetch("Madagascar", wait = TRUE,
                      download_dir = "data_s3/WDPA") 

# Téléchargement du contour des zones émergées de Madagascar
contour_mada <- gadm(country = "Madagascar", resolution = 1, level = 0,
                     path = "data_s3/GADM") %>%
  st_as_sf()

# Sauvegarde sur le serveur distant pour éviter de télécharger à chaque fois
# aws.s3::s3sync(path = "data_s3",
#                bucket = "fbedecarrats",
#                prefix = "diffusion/deforestation_madagascar/data_s3/",
#                create = FALSE,
#                region = "",
#                verbose = FALSE)

# On génère un rendu cartographique
tm_shape(contour_mada) +
  tm_polygons() +
  tm_shape(aires_prot_mada) + 
  tm_polygons(col = "IUCN_CAT", alpha = 0.6, title = "Catégorie IUCN") +
  # NB : on note les positions en majuscules quand on veut coller aux marges
  tm_credits("Sources: WDPA et GADM", position = c("RIGHT", "BOTTOM")) +
  tm_layout(main.title = "Aires protégées de Madagascar",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = map_title_size,
            legend.position = c("left", "top"),
            legend.outside = FALSE)

```


# Création d'un maillage en alvéoles

```{r Alvéoles, echo=FALSE, message=FALSE, warning=FALSE}

# Par souci de simplicité, on choisit un système de coordonnées supl : 
# Tananarive / UTM zone 39S, désigné par son code EPSG:29739
aires_prot_mada_proj <- aires_prot_mada %>%
  st_transform(crs = mon_scr)

cadre_autour_mada = st_as_sf(st_as_sfc(st_bbox(aires_prot_mada_proj)))

# Cellules de 5km de rayon
surface_cellule <- taille_hex * (1e+6)
taille_cellule <- 2 * sqrt(surface_cellule / ((3 * sqrt(3) / 2))) * sqrt(3) / 2
grille_mada <- st_make_grid(x = cadre_autour_mada,
                            cellsize = taille_cellule,
                            square = FALSE)
# On reprojette le contour des terres émergées pour qu'il ait le même système
# de coordonnées que notre maillage
contour_mada_proj <-  st_transform(contour_mada,
                                   crs = st_crs(grille_mada))
# On découpe la grille pour ne garder que les terres émergées
cellules_emergees <- st_intersects(contour_mada_proj, grille_mada) %>%
  unlist()
grille_mada <- grille_mada[sort(cellules_emergees)]
# On compte le nombre d'hexagones
n_hex <- length(grille_mada)

# Carte pour visualiser le résultat --------------------------------------------


## Carte de droite : zoom sur une zone spécifique-------------------------------
# On part d'un dataframe contenant une adresse
nom_centre_zoom <- "Maroantsetra"
zoom_centre <- data.frame(address = nom_centre_zoom) %>%
  geocode(address, method = "osm") %>% # on retrouve sa localisation xy
  select(long, lat) %>% # on ne garde que le xy
  as.numeric() %>% # qu'on passe en format numérique attendu par st_point
  st_point() %>% # On le spécifie en point
  st_sfc(crs = "EPSG:4326") %>% # on crée une géométrie en précisant que la source
  # est en WSG84, la norme pour les données issues d'internet
  st_transform(crs = mon_scr) # on la reprojette dans le système de référence du projet

# On crée une boîte de 100km 
zoom_boite <- zoom_centre %>% # On repart du centre
  st_buffer(dist = 50000) %>% # On crée un cercle de 50km de rayon
  st_make_grid(n = 1)%>%  # On crée un carré qui l'entoure
  st_transform(crs = mon_scr)

# On filtre les alvéoles pour ne garder que celles qui sont dans le zoom
grille_zoom <- st_intersection(grille_mada, zoom_boite)

# On télécharge un fond de carte pour la carte de droite
fond_carte_zoom <- get_tiles(zoom_boite, provider = "Stamen.Terrain", 
                             zoom = 10, crop = TRUE)
# On génère la carte de droite
carte_zoom <- tm_shape(fond_carte_zoom) + 
  tm_rgb() +
  tm_shape(grille_zoom) +
  tm_borders() +
  tm_shape(zoom_boite) + 
  tm_borders(col = "red") +
  tm_layout(frame = FALSE,
            main.title = paste("Zoom sur la zone de", nom_centre_zoom),
            main.title.size = map_title_size) +
  tm_credits(get_credit("Stamen.Toner"),
             bg.color = "white",
             align = "right",
             position = c("right", "BOTTOM"))

## Carte de gauche : simple à réaliser mais hexagones non visibles -------------
carte_grille <- tm_shape(grille_mada) +
  tm_polygons() + 
  tm_shape(zoom_boite) +
  tm_borders(col = "red") +
  tm_layout(frame = FALSE) +
  tm_layout(main.title = paste("Découpage en", n_hex,
                               "hexagones de", taille_hex*2, "km de diagonale"),
            main.title.size = map_title_size)

# Assemblage des deux cartes ---------------------------------------------------
tmap_arrange(carte_grille, carte_zoom, ncol = 2) 
```


