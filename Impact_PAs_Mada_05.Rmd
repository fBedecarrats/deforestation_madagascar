---
title: "Impact des aires protégées sur la déforestation à Madagascar"
author: "Florent Bédécarrats, Jeanne de Montalembert, Martin Ferry et Kenneth Houngbedji"
output:
  html_document:
    code_folding: hide
  pdf_document: 
    toc: yes
date: '2022-07-12'
editor_options:
  chunk_output_type: console
---

On réutilise le code fourni par Johannes Schielein: Jochen Kluve, Johannes Schielein, Melvin Wong, Yota Eilers, The KfW Protected Areas Portfolio: a Rigorous Impact Evaluation, KfW, 2022-07-08. 

On s'appuie sur le package R {mapme.biodiversity}, développé par la KfW dans le cadre de l'initiative commune MAPME qui associe la KfW et l'AFD. Le package {mapme.biodiversity} facilite l'acquisition et la préparation d'un grand nombre de données (CHIRPS, Global Forest Watch, FIRMS, SRTM, Worldpop...) et calculer un grand nombre d'indicateurs de manière harmonisée (active_fire_counts, biome classification, land cover classification, population count, precipitation, soil properties, tree cover loss, travel time...). Une documentation riche est disponible [sur le portail dédié du package en question](https://mapme-initiative.github.io/mapme.biodiversity/index.html).

On mobilise aussi les codes d'analyse d'impact développés par la même équipe et mise à disposition dans le dépôt Github: https://github.com/openkfw/mapme.protectedareas
Le code développé par l'équipe est assez complexe. A des fins pédagogiques et pour s'assurer qu'on l'a bien compris, on propose ici une version simplifiée (en cours de développement)


# Paramétrage

Les traitements sont réalisés en Rmarkdown. Le même code source peut générer un rendu en LaTeX/PDF, HTML ou Word. Les blocs de codes successifs sont exécutés en fonction de certains paramètres définis dans le premier bloc ("dispo_*").

```{r Evite d'afficher erreurs et messages pour tous les blocs}
# On supprime systématiquement les messages d'erreur ou d'info dans le document
# final généré (ils apparaissent dans la console) 
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```
```{r Installation et chargement des librairies requises}
# # Le package est en cours de développement, toujours installer la version en cours
# remotes::install_github("mapme-initiative/mapme.biodiversity", force = TRUE,
#                         upgrade = "always")

librairies_requises <- c( # On liste les librairies dont on a besoin
  "dplyr", # Pour faciliter la manipulation de données tabulaires
  "tidyr", # Pour reformater les données (pivots...)
  "sf", # Pour faciliter la manipulation de données géographiques
  "wdpar", # Pour télécharger simplement la base d'aires protégées WDPA
  "tmap", # Pour produire de jolies carte
  "geodata", # Pour télécharger simplement les frontières administratives
  "tidygeocoder", # pour obtenir les coordo GPS d'un point à partir de son nom
  "maptiles", # Pour télécharger des fonds de carte 
  "purrr", # Pour utiliser des formes fonctionnelles de programmation (ex. map)
  "mapme.biodiversity", # Acquisition et traitement des données du projet
  "survey") 

# On regarde parmi ces librairies lesquelles ne sont pas installées
manquantes <- !(librairies_requises %in% installed.packages())
# On installe celles qui manquent
if(any(manquantes)) install.packages(librairies_requises[manquantes])
# On charge toutes les librairies requises
lapply(librairies_requises, require, character.only= TRUE)
```
```{r Paramtères modifiables pour l'ensemble du document}
# Système de coordonnées géographiques utilisées pour le projet : EPSG:29739
mon_scr <- "EPSG:29739" # correspondant à Tananarive / UTM zone 39S
# Surface des hexagones en km2
taille_hex <- 5
# Taille des titres des cartes
map_title_size = 0.8
```



# Prépration des données


## Aires protégées

```{r Préparation aires protégées, eval = !dispo_aires_prot_mada}
# Ce qui suit jusqu'à la commande "save" ne s'execute que si le résultat n'a pas
# déjà été généré lors d'une exécution précédente.

# Téléchargement et chargement dans R des données d'aires protégées malgaches
aires_prot_mada <- wdpa_fetch("Madagascar", wait = TRUE,
                      download_dir = "data_s3/WDPA") %>%
  st_transform(crs = mon_scr) %>%
  filter(STATUS != "Proposed") %>%
  filter(DESIG != "Locally Managed Marine Area", DESIG != "Marine Park") 

# Téléchargement du contour des zones émergées de Madagascar
contour_mada <- gadm(country = "Madagascar", resolution = 1, level = 0,
                     path = "data_s3/GADM") %>%
  st_as_sf() %>% 
  st_transform(crs = mon_scr)


```


# Maillage en alvéoles (hexagones) du territoire

```{r Creation alveoles, eval = !dispo_grille_mada}
# Ce qui suit jusqu'à la commande "save" ne s'execute que si le résultat n'a pas
# déjà été généré lors d'une exécution précédente.

# On crée un cadre autour des aires protégées du pays
cadre_autour_mada = st_as_sf(st_as_sfc(st_bbox(aires_prot_mada)))

# Cellules de 5km de rayon
surface_cellule <- taille_hex * (1e+6)
taille_cellule <- 2 * sqrt(surface_cellule / ((3 * sqrt(3) / 2))) * sqrt(3) / 2
grille_mada <- st_make_grid(x = cadre_autour_mada,
                            cellsize = taille_cellule,
                            square = FALSE)
# On découpe la grille pour ne garder que les terres émergées
cellules_emergees <- st_intersects(contour_mada, grille_mada) %>%
  unlist()
grille_mada <- grille_mada[sort(cellules_emergees)] %>%
    st_sf()
```




## Données de matching: 
Les variables de matching utilisée par Schielein et al.  pour l'évaluation d'impact des aires protégées sont : traveltime_5k_110mio, traveltime_20k_110mio, terrain_ruggedness_index_mean,elevation_mean et soil_5_15cm_clay.

```{r}
dir.create("tmp")
grille_mada <- init_portfolio(x = grille_mada, 
                              years = 2000:2020,
                              outdir = "data_s3/mapme",
                              tmpdir = "tmp",
                              cores = 4,
                              add_resources = FALSE,
                              verbose = TRUE)
# Statistiques de couvert forestier, déforestation et équivalent CO2
grille_mada <- get_resources(x = grille_mada,
                             resources = c("treecover2000", "lossyear", 
                                           "greenhouse"))
grille_mada <- calc_indicators(x = grille_mada,
                               indicators = "treeloss", 
                               min_cover = 10, min_size = 1)

# On va changer de version de la librairie mapme.biodiversity. La précédente
# a été réalisée avec la version sur CRAN (0.1.2) et on va faire la suite avec
# la version plus récente disponible sur Github
detach("package:mapme.biodiversity", unload = TRUE)
remotes::install_github("mapme-initiative/mapme.biodiversity", 
                        upgrade = "always")
library(mapme.biodiversity)

# Statistiques d'accessibilité
grille_mada <-  get_resources(x = grille_mada, resource = "nelson_et_al",  
                              range_traveltime = "5k_110mio")
grille_mada <- calc_indicators(x = grille_mada,
                               "traveltime",  stats_accessibility = "mean",
                               engine = "extract")
# Statistiques de la qualité des sols
grille_mada <-  get_resources(x = grille_mada,
                              resources = "soilgrids",  layers = "clay", 
                              depths = "5-15cm", stats = "mean")
grille_mada <- calc_indicators(x = grille_mada,
                               "soilproperties", stats_soil = "mean", 
                               engine = "extract")
# Statistiques du terrain
grille_mada <- get_resources(x = grille_mada, resource = "nasa_srtm")
grille_mada <- calc_indicators(x = grille_mada,
                               resources = c("tri", "elevation"),
                               stats_tri = "mean", stats_elevation = "mean")

```

## Qualification des alvéoles selon qu'elle incluent une aire protégée 

```{r, eval = !dispo_grille_mada_AP}
# Le code suivant va asocier les hexagones aux aires protégées en se référant
# aux AP par leur rang dans la table des AP. On voudra plutôt leur identifiant, 
# alors on crée une table d'équivalence rang/identifiant 
aires_prot_mada_rang_id <- aires_prot_mada %>%
  st_drop_geometry() %>% # Enlève l'information spatiale
  mutate(AP_ligne = row_number()) %>% # Intègre le numéro de ligne dans un champ
  select(AP_ligne, WDPAID) # On ne garde que le numéro de ligne et l'identifiant

# Pour chaque hexagone, on va maintenant identifier s'ils touchent ("intersect")
# ou s'ils sont strictiement inclus dans ("within") une aire protégé
grille_mada <- grille_mada %>%
  mutate(AP_ligne = st_intersects(., aires_prot_mada), # liste des n° de lignes d'AP qui recoupent
         AP_ligne = map(AP_ligne, 1), # On extrait le 1° élément de la liste (toutes n'ont qu'1 élément)
         AP_ligne = as.integer(as.character(AP_ligne))) %>%  # formattage en numérique
  left_join(aires_prot_mada_rang_id, by = "AP_ligne") %>% # récupère l'id de l'AP
  rename(WDPAID_touche = WDPAID) %>% # on renomme pour différentier
  mutate(AP_ligne = st_within(., aires_prot_mada),
         AP_ligne = map(AP_ligne, 1),
         AP_ligne = as.integer(as.character(AP_ligne))) %>%
  left_join(aires_prot_mada_rang_id, by = "AP_ligne") %>%
  rename(WDPAID_inclus = WDPAID)

grille_mada <- grille_mada %>%
  st_sf() %>%
  mutate(position_ap = ifelse(is.na(WDPAID_touche), "Extérieur",
                                    ifelse(!is.na(WDPAID_inclus), "Intérieur",
                                                  "Frontière")))
```

# Graphiques


```{r Graph AP}
# On génère un rendu cartographique
tm_shape(contour_mada) +
  tm_polygons() +
  tm_shape(aires_prot_mada) + 
  tm_polygons(col = "IUCN_CAT", alpha = 0.6, title = "Catégorie IUCN") +
  # NB : on note les positions en majuscules quand on veut coller aux marges
  tm_credits("Sources: WDPA et GADM", position = c("RIGHT", "BOTTOM")) +
  tm_layout(main.title = "Aires protégées de Madagascar",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = map_title_size,
            legend.position = c("left", "top"),
            legend.outside = FALSE)
```


```{r Carte grille mada}
# On compte le nombre d'hexagones
n_hex <- length(grille_mada)
# Carte pour visualiser le résultat --------------------------------------------

## Carte de droite : zoom sur une zone spécifique-------------------------------
# On part d'un dataframe contenant une adresse
nom_centre_zoom <- "Maroantsetra"
zoom_centre <- data.frame(address = nom_centre_zoom) %>%
  geocode(address, method = "osm") %>% # on retrouve sa localisation xy
  select(long, lat) %>% # on ne garde que le xy
  as.numeric() %>% # qu'on passe en format numérique attendu par st_point
  st_point() %>% # On le spécifie en point
  st_sfc(crs = "EPSG:4326") %>% # on crée une géométrie en précisant que la source
  # est en WSG84, la norme pour les données issues d'internet
  st_transform(crs = mon_scr) # on la reprojette dans le système de référence du projet

# On crée une boîte de 100km 
zoom_boite <- zoom_centre %>% # On repart du centre
  st_buffer(dist = 50000) %>% # On crée un cercle de 50km de rayon
  st_make_grid(n = 1)%>%  # On crée un carré qui l'entoure
  st_transform(crs = mon_scr)

# On filtre les alvéoles pour ne garder que celles qui sont dans le zoom
grille_zoom <- st_intersection(grille_mada, zoom_boite)

# On télécharge un fond de carte pour la carte de droite
fond_carte_zoom <- get_tiles(zoom_boite, provider = "Stamen.Terrain", 
                             zoom = 10, crop = TRUE)
# On génère la carte de droite
carte_zoom <- tm_shape(fond_carte_zoom) + 
  tm_rgb() +
  tm_shape(grille_zoom) +
  tm_borders() +
  tm_shape(zoom_boite) + 
  tm_borders(col = "red") +
  tm_layout(frame = FALSE,
            main.title = paste("Zoom sur la zone de", nom_centre_zoom),
            main.title.size = map_title_size) +
  tm_credits(get_credit("Stamen.Toner"),
             bg.color = "white",
             align = "right",
             position = c("right", "BOTTOM"))

## Carte de gauche : simple à réaliser mais hexagones non visibles -------------
carte_grille <- tm_shape(grille_mada) +
  tm_polygons() + 
  tm_shape(zoom_boite) +
  tm_borders(col = "red") +
  tm_layout(frame = FALSE) +
  tm_layout(main.title = paste("Découpage en", n_hex,
                               "hexagones de", taille_hex*2, "km2"),
            main.title.size = map_title_size)

# Assemblage des deux cartes ---------------------------------------------------
tmap_arrange(carte_grille, carte_zoom, ncol = 2) 
```


```{r Graph alvéoles AP}
tmap_mode("plot")
# Une vue après classification
tm_shape(grille_mada) +
  tm_fill(col = "position_ap", title = "par rapport aux aires protégées") +
  tm_layout(main.title = "Localisation des hexagones",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = map_title_size,
            legend.position = c("left", "top"),
            legend.outside = FALSE)
```


```{r Graphs couvert forestier}
tm_shape(grille_mada) +
  tm_fill(c("treecover_2000", "var_treecover", "sum_emissions"),
          title = c("Couvert arboré en 2000", "Variation 2000 et 2020",
                    "Emissions en CO2eq"),
          palette = list("Greens", "Reds", "Blues")) +
  tm_layout(main.title = "Évolution du couvert forestier",
            main.title.size = map_title_size)
```


```{r Graph travel time}

grille_mada_summary <- grille_mada %>%
  unnest(cols = traveltime) %>%
  select(-minutes_median, -minutes_sd) %>%
  pivot_wider(names_from = "distance", values_from = "minutes_mean",
              names_prefix = "distance_")


tm_shape(grille_mada_summary) +
  tm_fill("distance_20k_110mio", n = 20, title = "Trajet en minutes") +
  tm_layout(legend.outside = TRUE) +
  tm_shape(contour_mada) +
  tm_borders() +
  tm_layout(main.title = "Distance par rapport à une ville >20K habitants",
            main.title.size = map_title_size)
```

# A faire   

- Préciser les types d'aires protégées à conserver    
- Corriger/enrichir les métadonnées des aires protégées avec les informations recueillies par Jeanne   
- Ajouter une biblio   
- Vérifier la préséance lorsque un hexa recoupe plusieurs AP (rang IUCN en premier) 
- Expliciter les unités.
