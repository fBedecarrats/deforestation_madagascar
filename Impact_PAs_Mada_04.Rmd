---
title: "Impact des aires protégées sur la déforestation à Madagascar"
author: "Florent Bédécarrats, Jeanne de Montalembert, Martin Ferry et Kenneth Houngbedji"
output:
  html_document:
    code_folding: hide
  pdf_document: 
    toc: yes
date: '2022-07-12'
editor_options:
  chunk_output_type: console
---

On réutilise le code fourni par Johannes Schielein: Jochen Kluve, Johannes Schielein, Melvin Wong, Yota Eilers, The KfW Protected Areas Portfolio: a Rigorous Impact Evaluation, KfW, 2022-07-08. 

On s'appuie sur le package R {mapme.biodiversity}, développé par la KfW dans le cadre de l'initiative commune MAPME qui associe la KfW et l'AFD. Le package {mapme.biodiversity} facilite l'acquisition et la préparation d'un grand nombre de données (CHIRPS, Global Forest Watch, FIRMS, SRTM, Worldpop...) et calculer un grand nombre d'indicateurs de manière harmonisée (active_fire_counts, biome classification, land cover classification, population count, precipitation, soil properties, tree cover loss, travel time...). Une documentation riche est disponible [sur le portail dédié du package en question](https://mapme-initiative.github.io/mapme.biodiversity/index.html).

On mobilise aussi les codes d'analyse d'impact développés par la même équipe et mise à disposition dans le dépôt Github: https://github.com/openkfw/mapme.protectedareas
Le code développé par l'équipe est assez complexe. A des fins pédagogiques et pour s'assurer qu'on l'a bien compris, on propose ici une version simplifiée (en cours de développement)


# Paramétrage

Les traitements sont réalisés en Rmarkdown. Le même code source peut générer un rendu en LaTeX/PDF, HTML ou Word. Les blocs de codes successifs sont exécutés en fonction de certains paramètres définis dans le premier bloc ("dispo_*").

```{r Librairies et paramètres, message=FALSE, warning=FALSE}
# On supprime systématiquement les messages d'erreur ou d'info dans le document
# final généré (ils apparaissent dans la console) 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

# Le package est en cours de développement, toujours installer la version en cours
remotes::install_github("mapme-initiative/mapme.biodiversity", force = TRUE,
                        upgrade = "always")

# Si certaines librairies ne pas installées
library(dplyr) # Pour faciliter la manipulation de données tabulaires
library(tidyr) # Pour reformater les données (pivots...)
library(sf) # Pour faciliter la manipulation de données géographiques
library(wdpar) # Pour télécharger simplement la base d'aires protégées WDPA
library(tmap) # Pour produire de jolies carte
library(mapview) # à enlever ? redondant avec tmap
library(geodata) # Pour télécharger simplement les frontières administratives
library(tidygeocoder) # pour obtenir les coordo GPS d'un point à partir de son nom
library(maptiles) # Pour télécharger des fonds de carte 
library(purrr) # Pour utiliser des formes fonctionnelles de programmation (ex. map)
library(mapme.biodiversity)

# Système de coordonnées géographiques utilisées pour le projet : EPSG:29739
mon_scr <- "EPSG:29739" # correspondant à Tananarive / UTM zone 39S
# Surface des hexagones en km2
taille_hex <- 5
# Taille des titres des cartes
map_title_size = 0.8

# On définit les emplacement pour les principaux fichiers générés par le script
fichier_aires_prot_mada <- "data_s3/aires_prot_mada.rds"
fichier_grille_mada <- "data_s3/grille_mada.rds"
fichier_grille_mada_AP <- "data_s3/grille_mada_aires_prot.rds"
fichier_grille_mada_AP_trees <- "data_s3/grille_mada_AP_trees.rds"
fichier_grille_AP_trees_access <- "data_s3/grille_AP_trees_access.rds"
fichier_grille_AP_trees_access_soil <- "data_s3/grille_AP_trees_access_soil.rds"
fichier_grille_AP_trees_access_soil_srtm <- "data_s3/grille_AP_trees_access_soil_srtm.rds"

# On calcule des variables logiques pour chaque bloc : si le bloc de code a déjà 
# tourné et généré un résultat statisfaisant, on charge juste son résultat.
# Sinon on génère à nouveau
dispo_aires_prot_mada <- file.exists(fichier_aires_prot_mada)
dispo_grille_mada <- file.exists(fichier_grille_mada)
dispo_grille_mada_AP <- file.exists(fichier_grille_mada_AP)
dispo_grille_mada_AP_trees <- file.exists(fichier_grille_mada_AP_trees)
dispo_grille_AP_trees_access <- file.exists(fichier_grille_AP_trees_access)
dispo_grille_AP_trees_access_soil <- file.exists(fichier_grille_AP_trees_access_soil)
dispo_grille_AP_trees_access_soil_srtm <- file.exists(fichier_grille_AP_trees_access_soil_srtm)
```

# Prépration des données


## Préparation des données d'aires protégées

```{r Préparation aires protégées, eval = !dispo_aires_prot_mada}
# Ce qui suit jusqu'à la commande "save" ne s'execute que si le résultat n'a pas
# déjà été généré lors d'une exécution précédente.

# Téléchargement et chargement dans R des données d'aires protégées malgaches
aires_prot_mada <- wdpa_fetch("Madagascar", wait = TRUE,
                      download_dir = "data_s3/WDPA") %>%
  st_transform(crs = mon_scr) %>%
  filter(STATUS != "Proposed") %>%
  filter(DESIG != "Locally Managed Marine Area", DESIG != "Marine Park") 

# Téléchargement du contour des zones émergées de Madagascar
contour_mada <- gadm(country = "Madagascar", resolution = 1, level = 0,
                     path = "data_s3/GADM") %>%
  st_as_sf() %>% 
  st_transform(crs = mon_scr)

# On sauve les objets créés pendant cette séquence
save(aires_prot_mada, contour_mada, file = fichier_aires_prot_mada)
```
```{r Chargement AP, eval=dispo_aires_prot_mada}
# La commande ci-dessous ne s'execute que si le résultat est déjà disponible
load(fichier_aires_prot_mada)
```
```{r Graph AP}
# On génère un rendu cartographique
tm_shape(contour_mada) +
  tm_polygons() +
  tm_shape(aires_prot_mada) + 
  tm_polygons(col = "IUCN_CAT", alpha = 0.6, title = "Catégorie IUCN") +
  # NB : on note les positions en majuscules quand on veut coller aux marges
  tm_credits("Sources: WDPA et GADM", position = c("RIGHT", "BOTTOM")) +
  tm_layout(main.title = "Aires protégées de Madagascar",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = map_title_size,
            legend.position = c("left", "top"),
            legend.outside = FALSE)
```


## Création d'un maillage en alvéoles couvrant l'ensemble du territoire malgache

```{r Creation alveoles, eval = !dispo_grille_mada}
# Ce qui suit jusqu'à la commande "save" ne s'execute que si le résultat n'a pas
# déjà été généré lors d'une exécution précédente.

# On crée un cadre autour des aires protégées du pays
cadre_autour_mada = st_as_sf(st_as_sfc(st_bbox(aires_prot_mada)))

# Cellules de 5km de rayon
surface_cellule <- taille_hex * (1e+6)
taille_cellule <- 2 * sqrt(surface_cellule / ((3 * sqrt(3) / 2))) * sqrt(3) / 2
grille_mada <- st_make_grid(x = cadre_autour_mada,
                            cellsize = taille_cellule,
                            square = FALSE)
# On découpe la grille pour ne garder que les terres émergées
cellules_emergees <- st_intersects(contour_mada, grille_mada) %>%
  unlist()
grille_mada <- grille_mada[sort(cellules_emergees)] %>%
    st_sf()

# On sauve les objets créés lors de cette séquence
save(grille_mada, file = fichier_grille_mada) 

# # On teste que les hexagones ont bien la taille prévue
# test <- grille_mada %>%
#   mutate(area = st_area(.))
# # On a bien 5 000 000 m2 par hexagone (1 km2)
```
```{r Charge grille Mada, eval = dispo_grille_mada}
load(fichier_grille_mada)
```
```{r Carte grille mada}
# On compte le nombre d'hexagones
n_hex <- length(grille_mada)
# Carte pour visualiser le résultat --------------------------------------------

## Carte de droite : zoom sur une zone spécifique-------------------------------
# On part d'un dataframe contenant une adresse
nom_centre_zoom <- "Maroantsetra"
zoom_centre <- data.frame(address = nom_centre_zoom) %>%
  geocode(address, method = "osm") %>% # on retrouve sa localisation xy
  select(long, lat) %>% # on ne garde que le xy
  as.numeric() %>% # qu'on passe en format numérique attendu par st_point
  st_point() %>% # On le spécifie en point
  st_sfc(crs = "EPSG:4326") %>% # on crée une géométrie en précisant que la source
  # est en WSG84, la norme pour les données issues d'internet
  st_transform(crs = mon_scr) # on la reprojette dans le système de référence du projet

# On crée une boîte de 100km 
zoom_boite <- zoom_centre %>% # On repart du centre
  st_buffer(dist = 50000) %>% # On crée un cercle de 50km de rayon
  st_make_grid(n = 1)%>%  # On crée un carré qui l'entoure
  st_transform(crs = mon_scr)

# On filtre les alvéoles pour ne garder que celles qui sont dans le zoom
grille_zoom <- st_intersection(grille_mada, zoom_boite)

# On télécharge un fond de carte pour la carte de droite
fond_carte_zoom <- get_tiles(zoom_boite, provider = "Stamen.Terrain", 
                             zoom = 10, crop = TRUE)
# On génère la carte de droite
carte_zoom <- tm_shape(fond_carte_zoom) + 
  tm_rgb() +
  tm_shape(grille_zoom) +
  tm_borders() +
  tm_shape(zoom_boite) + 
  tm_borders(col = "red") +
  tm_layout(frame = FALSE,
            main.title = paste("Zoom sur la zone de", nom_centre_zoom),
            main.title.size = map_title_size) +
  tm_credits(get_credit("Stamen.Toner"),
             bg.color = "white",
             align = "right",
             position = c("right", "BOTTOM"))

## Carte de gauche : simple à réaliser mais hexagones non visibles -------------
carte_grille <- tm_shape(grille_mada) +
  tm_polygons() + 
  tm_shape(zoom_boite) +
  tm_borders(col = "red") +
  tm_layout(frame = FALSE) +
  tm_layout(main.title = paste("Découpage en", n_hex,
                               "hexagones de", taille_hex*2, "km2"),
            main.title.size = map_title_size)

# Assemblage des deux cartes ---------------------------------------------------
tmap_arrange(carte_grille, carte_zoom, ncol = 2) 
```


## Qualification des alvéoles selon qu'elle incluent une aire protégée 

```{r, eval = !dispo_grille_mada_AP}
# Le code suivant va asocier les hexagones aux aires protégées en se référant
# aux AP par leur rang dans la table des AP. On voudra plutôt leur identifiant, 
# alors on crée une table d'équivalence rang/identifiant 
aires_prot_mada_rang_id <- aires_prot_mada %>%
  st_drop_geometry() %>% # Enlève l'information spatiale
  mutate(AP_ligne = row_number()) %>% # Intègre le numéro de ligne dans un champ
  select(AP_ligne, WDPAID) # On ne garde que le numéro de ligne et l'identifiant

# Pour chaque hexagone, on va maintenant identifier s'ils touchent ("intersect")
# ou s'ils sont strictiement inclus dans ("within") une aire protégé
grille_mada <- grille_mada %>%
  mutate(AP_ligne = st_intersects(., aires_prot_mada), # liste des n° de lignes d'AP qui recoupent
         AP_ligne = map(AP_ligne, 1), # On extrait le 1° élément de la liste (toutes n'ont qu'1 élément)
         AP_ligne = as.integer(as.character(AP_ligne))) %>%  # formattage en numérique
  left_join(aires_prot_mada_rang_id, by = "AP_ligne") %>% # récupère l'id de l'AP
  rename(WDPAID_touche = WDPAID) %>% # on renomme pour différentier
  mutate(AP_ligne = st_within(., aires_prot_mada),
         AP_ligne = map(AP_ligne, 1),
         AP_ligne = as.integer(as.character(AP_ligne))) %>%
  left_join(aires_prot_mada_rang_id, by = "AP_ligne") %>%
  rename(WDPAID_inclus = WDPAID)

grille_mada <- grille_mada %>%
  st_sf() %>%
  mutate(position_ap = ifelse(is.na(WDPAID_touche), "Extérieur",
                                    ifelse(!is.na(WDPAID_inclus), "Intérieur",
                                                  "Frontière")))

save(grille_mada, file = fichier_grille_mada_AP)
```
```{r Charge la grille avec les infos AP, eval = dispo_grille_mada_AP}
load(fichier_grille_mada_AP)
```
```{r Graph alvéoles AP}
tmap_mode("plot")
# Une vue après classification
tm_shape(grille_mada) +
  tm_fill(col = "position_ap", title = "par rapport aux aires protégées") +
  tm_layout(main.title = "Localisation des hexagones",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = map_title_size,
            legend.position = c("left", "top"),
            legend.outside = FALSE)
```

## Acquisition et préparation des données relatives au couvert forestier

```{r, eval = !dispo_grille_mada_AP_trees}
# # Test avec une zone restreinte : Lac Alaotra
# grille_alaotra <- grille_mada %>%
#   filter(WDPAID_inclus == 901296)
# tmap_mode("view")
# tm_shape(grille_alaotra) +
#   tm_polygons()
# aoi <- grille_alaotra

aoi <- grille_mada
aoi2 <- init_portfolio(x = aoi, 
                       years = 2000:2020,
                       outdir = "data_s3/mapme",
                       tmpdir = "data_s3/tmp",
                       cores = 16,
                      verbose = TRUE)
aoi2 = get_resources(aoi2, resources = c("treecover2000", "lossyear", "greenhouse"))
aoi3 = split(aoi2, (seq(nrow(aoi2))-1) %/% 10000)

dir.create("data_s3/mapme/treeloss")

start_time = Sys.time()

for(i in 1:length(aoi3)){
  filename = file.path("data_s3/mapme/treeloss", paste0("hexa_", i, ".rds"))
  if(file.exists(filename)) next
  tmp = aoi3[[i]]
  tmp = calc_indicators(tmp, indicators = "treeloss", min_cover = 10, min_size = 1)
  saveRDS(tmp, filename)
  rm(tmp); gc()
  aoi3[[i]] = NA
}

end_time = Sys.time()
print(end_time - start_time)

rds_files = list.files("data_s3/mapme/treeloss", pattern = ".rds$", full.names = TRUE)
grille_mada = lapply(rds_files, function(f) readRDS(f))
grille_mada = st_as_sf(purrr::map_dfr(grille_mada, rbind))

# Une solution pour avoir une version plus tabulaire
# tabular <- grille_mada %>%
#            unnest(cols = treeloss) %>%
#   pivot_wider(names_from = "years", values_from = c("treecover", "emissions"))
grille_mada_summary <- grille_mada %>%
  unnest(cols = treeloss) %>%
  pivot_wider(names_from = "years", values_from = c("treecover", "emissions")) %>%
  mutate(var_treecover = (treecover_2020 - treecover_2000)/treecover_2000,
         sum_emissions = sum(c_across(starts_with("emission")), na.rm = T)) %>%
  rename(init_treecover_2000 = treecover_2000) %>% # renomme pour ne pas l'éliminer à la ligne suivante
  select(-starts_with("treecover"), -starts_with("emission")) %>%
  rename(treecover_2000 = init_treecover_2000) %>%
  select(treecover_2000, var_treecover, sum_emissions)

grille_mada <- bind_cols(grille_mada, grille_mada_summary)

save(grille_mada, file = fichier_grille_mada_AP_trees)

# Sauvegarde sur le serveur distant pour éviter de télécharger à chaque fois
aws.s3::s3sync(path = "data_s3",
               bucket = "fbedecarrats",
               prefix = "diffusion/deforestation_madagascar/data_s3/",
               create = FALSE,
               region = "",
               verbose = FALSE)
# L'exécution de ce bloc est problématique sur l'environnement de calcul
# utilisé (onyxia/SSP-Cloud), probablement car il s'agit d'un cluster kubernetes
# et que la parallélisation sous R supporte mal cette configuration.
```
```{r, eval = dispo_grille_mada_AP_trees}
load(fichier_grille_mada_AP_trees)
```
```{r Graphs couvert forestier}
tm_shape(grille_mada) +
  tm_fill(c("treecover_2000", "var_treecover", "sum_emissions"),
          title = c("Couvert arboré en 2000", "Variation 2000 et 2020",
                    "Emissions en CO2eq"),
          palette = list("Greens", "Reds", "Blues")) +
  tm_layout(main.title = "Évolution du couvert forestier",
            main.title.size = map_title_size)
```

## Données de matching: 
Les variables de matching utilisée par Schielein et al.  pour l'évaluation d'impact des aires protégées sont : traveltime_5k_110mio, traveltime_20k_110mio, terrain_ruggedness_index_mean,elevation_mean et soil_5_15cm_clay.

```{r Compute travel time, eval=!dispo_grille_AP_trees_access}
dir.create("data_s3/mapme/access")
dir.create("tmp")

aoi <- grille_mada
aoi2 <- init_portfolio(x = aoi, 
                       years = 2000:2020,
                       outdir = "data_s3/mapme",
                        tmpdir = "tmp",
                       cores = 1, # étendre pour plus d'efficacité 
                       add_resources = FALSE,
                      verbose = TRUE)
aoi2 <- get_resources(aoi2, resource = "nelson_et_al",
                      range_traveltime = c("5k_110mio", "20k_110mio"))
aoi3 <- split(aoi2, (seq(nrow(aoi2))-1) %/% 10000)

for(i in 1:length(aoi3)){
  filename = file.path("data_s3/mapme/access", paste0("hexa_", i, ".rds"))
  if(file.exists(filename)) next
  tmp = aoi3[[i]]
   tmp = calc_indicators(tmp, 
                        indicators = c("traveltime"),
                        stats_accessibility = c("mean"),
                        engine = "extract")
  saveRDS(tmp, filename)
  rm(tmp); gc()
  aoi3[[i]] = NA
}


rds_files = list.files("data_s3/mapme/access", pattern = ".rds$", full.names = TRUE)
grille_mada = lapply(rds_files, function(f) readRDS(f))
grille_mada = st_as_sf(purrr::map_dfr(grille_mada, rbind))

save(grille_mada, file = fichier_grille_AP_trees_access)
```
```{r Load travel time data, eval = dispo_grille_AP_trees_access}
load(fichier_grille_AP_trees_access)
```
```{r Graph travel time}

grille_mada_summary <- grille_mada %>%
  unnest(cols = traveltime) %>%
  select(-minutes_median, -minutes_sd) %>%
  pivot_wider(names_from = "distance", values_from = "minutes_mean",
              names_prefix = "distance_")


tm_shape(grille_mada_summary) +
  tm_fill("distance_20k_110mio", n = 20, title = "Trajet en minutes") +
  tm_layout(legend.outside = TRUE) +
  tm_shape(contour_mada) +
  tm_borders() +
  tm_layout(main.title = "Distance par rapport à une ville >20K habitants",
            main.title.size = map_title_size)
```

terrain_ruggedness_index_mean
elevation_mean
soil_5_15cm_clay
```{r, eval = !dispo_grille_AP_trees_access_soil_srtm}
dir.create("tmp")

aoi <- grille_mada
aoi2 <- init_portfolio(x = aoi, 
                       years = 2000:2020,
                       outdir = "data_s3/mapme",
                        tmpdir = "tmp",
                       cores = 4, # étendre pour plus d'efficacité 
                      add_resources = FALSE,
                      verbose = TRUE)
aoi2 <- get_resources(aoi2, resources = c("soilgrids"), 
                     layers = "clay", depths = "5-15cm", stats = "mean")

aoi3 <- calc_indicators(aoi2, 
                        indicators = c("soilproperties"),
                        stats_soil = c("mean"),
                        engine = "extract")

grille_mada <- aoi3

save(grille_mada, file = fichier_grille_AP_trees_access_soil_srtm)
```
```{r, eval = dispo_grille_AP_trees_access_soil_srtm}
load(fichier_grille_AP_trees_access_soil)
```

terrain_ruggedness_index_mean
elevation_mean
```{r, eval = !dispo_grille_AP_trees_access_soil_srtm}
dir.create("tmp")

aoi <- grille_mada
aoi2 <- init_portfolio(x = aoi, 
                       years = 2000:2020,
                       outdir = "data_s3/mapme",
                        tmpdir = "tmp",
                       cores = 4, # étendre pour plus d'efficacité 
                      add_resources = FALSE,
                      verbose = TRUE)
aoi2 = get_resources(aoi2, resources = "srtmdem")

aoi3 = calc_indicators(aoi2, indicators = c("tri", "elevation"),  
                        stats_tri = "mean", stats_elevation = "mean")

grille_mada <- aoi3

save(grille_mada, file = fichier_grille_AP_trees_access_soil_srtm)
```


Factoriser en un seul coup
```{r}
dir.create("tmp")
grille_mada <- init_portfolio(x = grille_mada, 
                              years = 2000:2020,
                              outdir = "data_s3/mapme",
                              tmpdir = "tmp",
                              cores = 4,
                              verbose = TRUE)

grille_mada <- grille_mada %>%
  # Statistiques de couvert forestier, déforestation et équivalent CO2
  get_resources(resources = c("treecover2000", "lossyear", "greenhouse")) %>%
  calc_indicators(indicators = "treeloss", min_cover = 10, min_size = 1) %>%
  # Statistiques d'accessibilité
  get_resources(resource = "nelson_et_al",  range_traveltime = "5k_110mio") %>%
  calc_indicators("traveltime",  stats_accessibility = "mean",
                  engine = "extract") %>%
  # Statistiques du terrain
  get_resources("srtmdem") %>%
  calc_indicators(c("tri", "elevation"),
                  stats_tri = "mean", stats_elevation = "mean") %>%
  # Statistiques de la qualité des sols
  get_resources("soilgrids",  layers = "clay", depths = "5-15cm", 
                stats = "mean") %>%
  calc_indicators("soilproperties", stats_soil = "mean", engine = "extract")

```


# A faire   

- Préciser les types d'aires protégées à conserver    
- Corriger/enrichir les métadonnées des aires protégées avec les informations recueillies par Jeanne   
- Ajouter une biblio   
- Vérifier la préséance lorsque un hexa recoupe plusieurs AP (rang IUCN en premier) 
- Expliciter les unités.
