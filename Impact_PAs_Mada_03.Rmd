---
title: Analyse de l'impact des aires protégées à Madagascar à partir de la méthode
  KfW
output:
  pdf_document: default
  html_document: default
date: '2022-07-12'
editor_options:
  chunk_output_type: console
---

On réutilise le code fourni par Johannes Schielein: Jochen Kluve, Johannes Schielein, Melvin Wong, Yota Eilers, The KfW Protected Areas Portfolio: a Rigorous Impact Evaluation, KfW, 2022-07-08.

# A faire
Préciser les types d'aires à conserver

```{r Librairies et paramètres, echo=FALSE, message=FALSE, warning=FALSE}
# Si certaines librairies ne pas installées
library(dplyr) # Pour faciliter la manipulation de données tabulaires
library(sf) # Pour faciliter la manipulation de données géographiques
library(wdpar) # Pour télécharger simplement la base d'aires protégées WDPA
library(tmap) # Pour produire de jolies carte
library(mapview) # à enlever ? redondant avec tmap
library(geodata) # Pour télécharger simplement les frontières administratives
library(tidygeocoder) # pour obtenir les coordo GPS d'un point à partir de son nom
library(maptiles) # Pour télécharger des fonds de carte 

# Système de coordonnées géographiques utilisées pour le projet : EPSG:29739
mon_scr <- "EPSG:29739" # correspondant à Tananarive / UTM zone 39S
# taille du "rayon" des hexagones
taille_hex <- 5
# Taille des titres des cartes
map_title_size = 0.7
```



# On charge les données de WDPA

```{r Chargement des données, echo=FALSE, message=FALSE, warning=FALSE}

# Téléchargement et chargement dans R des données d'aires protégées malgaches
aires_prot_mada <- wdpa_fetch("Madagascar", wait = TRUE,
                      download_dir = "data_s3/WDPA") %>%
  st_transform(crs = mon_scr) %>%
  filter(STATUS != "Proposed") %>%
  filter(DESIG != "Locally Managed Marine Area", DESIG != "Marine Park") %>% 
  st_transform(crs = st_crs(mon_scr))

# Téléchargement du contour des zones émergées de Madagascar
contour_mada <- gadm(country = "Madagascar", resolution = 1, level = 0,
                     path = "data_s3/GADM") %>%
  st_as_sf() %>% 
  st_transform(crs = st_crs(mon_scr))

# Sauvegarde sur le serveur distant pour éviter de télécharger à chaque fois
# aws.s3::s3sync(path = "data_s3",
#                bucket = "fbedecarrats",
#                prefix = "diffusion/deforestation_madagascar/data_s3/",
#                create = FALSE,
#                region = "",
#                verbose = FALSE)

# On génère un rendu cartographique
tm_shape(contour_mada) +
  tm_polygons() +
  tm_shape(aires_prot_mada) + 
  tm_polygons(col = "IUCN_CAT", alpha = 0.6, title = "Catégorie IUCN") +
  # NB : on note les positions en majuscules quand on veut coller aux marges
  tm_credits("Sources: WDPA et GADM", position = c("RIGHT", "BOTTOM")) +
  tm_layout(main.title = "Aires protégées de Madagascar",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = map_title_size,
            legend.position = c("left", "top"),
            legend.outside = FALSE)

```


# Création d'un maillage en alvéoles

```{r Alvéoles, echo=FALSE, message=FALSE, warning=FALSE}

cadre_autour_mada = st_as_sf(st_as_sfc(st_bbox(aires_prot_mada)))

# Cellules de 5km de rayon
surface_cellule <- taille_hex * (1e+6)
taille_cellule <- 2 * sqrt(surface_cellule / ((3 * sqrt(3) / 2))) * sqrt(3) / 2
grille_mada <- st_make_grid(x = cadre_autour_mada,
                            cellsize = taille_cellule,
                            square = FALSE)
# On découpe la grille pour ne garder que les terres émergées
cellules_emergees <- st_intersects(contour_mada, grille_mada) %>%
  unlist()
grille_mada <- grille_mada[sort(cellules_emergees)]
# On compte le nombre d'hexagones
n_hex <- length(grille_mada)

# Carte pour visualiser le résultat --------------------------------------------

## Carte de droite : zoom sur une zone spécifique-------------------------------
# On part d'un dataframe contenant une adresse
nom_centre_zoom <- "Maroantsetra"
zoom_centre <- data.frame(address = nom_centre_zoom) %>%
  geocode(address, method = "osm") %>% # on retrouve sa localisation xy
  select(long, lat) %>% # on ne garde que le xy
  as.numeric() %>% # qu'on passe en format numérique attendu par st_point
  st_point() %>% # On le spécifie en point
  st_sfc(crs = "EPSG:4326") %>% # on crée une géométrie en précisant que la source
  # est en WSG84, la norme pour les données issues d'internet
  st_transform(crs = mon_scr) # on la reprojette dans le système de référence du projet

# On crée une boîte de 100km 
zoom_boite <- zoom_centre %>% # On repart du centre
  st_buffer(dist = 50000) %>% # On crée un cercle de 50km de rayon
  st_make_grid(n = 1)%>%  # On crée un carré qui l'entoure
  st_transform(crs = mon_scr)

# On filtre les alvéoles pour ne garder que celles qui sont dans le zoom
grille_zoom <- st_intersection(grille_mada, zoom_boite)

# On télécharge un fond de carte pour la carte de droite
fond_carte_zoom <- get_tiles(zoom_boite, provider = "Stamen.Terrain", 
                             zoom = 10, crop = TRUE)
# On génère la carte de droite
carte_zoom <- tm_shape(fond_carte_zoom) + 
  tm_rgb() +
  tm_shape(grille_zoom) +
  tm_borders() +
  tm_shape(zoom_boite) + 
  tm_borders(col = "red") +
  tm_layout(frame = FALSE,
            main.title = paste("Zoom sur la zone de", nom_centre_zoom),
            main.title.size = map_title_size) +
  tm_credits(get_credit("Stamen.Toner"),
             bg.color = "white",
             align = "right",
             position = c("right", "BOTTOM"))

## Carte de gauche : simple à réaliser mais hexagones non visibles -------------
carte_grille <- tm_shape(grille_mada) +
  tm_polygons() + 
  tm_shape(zoom_boite) +
  tm_borders(col = "red") +
  tm_layout(frame = FALSE) +
  tm_layout(main.title = paste("Découpage en", n_hex,
                               "hexagones de", taille_hex*2, "km de diagonale"),
            main.title.size = map_title_size)

# Assemblage des deux cartes ---------------------------------------------------
tmap_arrange(carte_grille, carte_zoom, ncol = 2) 
```

Maintenant on va qualifier le contenu des hexagones

```{r}
AP2 <- aires_prot_mada_proj  # %>%
  # filter(DESIG_ENG != "UNESCO-MAB Biosphere Reserve")
  # st_make_valid() 

# Le code suivant va asocier les hexagones aux aires protégées en se référant
# aux AP par leur rang dans la table des AP. On voudra plutôt leur identifiant, 
# alors on crée une table d'équivalence rang/identifiant 
aires_prot_mada_rang_id <- aires_prot_mada_proj %>%
  st_drop_geometry() %>% # Enlève l'information spatiale
  mutate(AP_ligne = row_number()) %>% # Intègre le numéro de ligne dans un champ
  select(AP_ligne, WDPAID) # On ne garde que le numéro de ligne et l'identifiant




grille_mada_AP <- grille_mada %>%
  st_sf() %>%
  mutate(AP_ligne = st_intersects(., AP2), # liste des n° de lignes d'AP qui recoupent
        # AP_ligne = map(AP_ligne, 1), # On extrait le 1° élément de la liste (toutes n'ont qu'1 élément)
         AP_ligne = as.integer(as.character(AP_ligne))) %>%  # formattage en numérique
  left_join(tibble(AP_ligne = AP2$AP_ligne, dans_AP_id = AP2$WDPAID), 
            by = "AP_ligne") %>% # récupère l'id de l'AP
  mutate(AP_ligne = st_within(., AP2),
         AP_ligne = map(AP_ligne, 1),
         AP_ligne = as.integer(as.character(AP_ligne))) %>%
  left_join(tibble(AP_ligne = AP2$AP_ligne, dans_AP_id = AP2$WDPAID), 
            by = "AP_ligne")

test1 <- test %>% 
         mutate(num_ligne_WDPA = map(num_ligne_WDPA, 1),
                num_ligne_WDPA = as.integer(as.character(num_ligne_WDPA)))



AP_2_test <- AP_2 %>%
  mutate(num_ligne_WDPA = row_number()) %>%
  st_drop_geometry()

test2 <- test1 %>%
  left_join(AP_2_test, by = "num_ligne_WDPA")


table(length(test$intersects_PA))

test2[[1]]
rm(test2)
 st_intersects(AP_2)

test <- grille_mada %>%
  mutate(test = 1)

hexa_within_PA_list <- grille_mada %>%
  st_within(AP_2,sparse = T)

hexa_intersec_PA <- data.frame(row.id=rep(seq_along(hexa_intersec_PA_list), 
                                          lengths(hexa_intersec_PA_list)), 
                               col.id=unlist(hexa_intersec_PA_list))

hexa_within_PA <- data.frame(row.id=rep(seq_along(hexa_within_PA_list), 
                                          lengths(hexa_within_PA_list)), 
                               col.id=unlist(hexa_within_PA_list))

library(purrr)
test <- hexa_intersec_PA_list %>%
  map("Value")
hexa_intersec_PA_list[["Value"]]
table(str(hexa_intersec_PA_list))
```


